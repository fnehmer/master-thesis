%!TEX encoding = UTF-8 Unicode
% ================================================================================
\documentclass[
    fontsize=12pt,
    headings=small,
    parskip=half,           % Ersetzt manuelles Setzen von parskip/parindent.
    bibliography=totoc,
    numbers=noenddot,       % Entfernt den letzten Punkt der Kapitelnummern.
    open=any,               % Kapitel kann auf jeder Seite beginnen.
%   final                   % Entfernt alle todonotes und den Entwurfstempel.
    ]{scrreprt}
% ===================================Praeambel==================================
\include{stylesvs}
% ===================================Dokument===================================

\title{Intrusion detection for OAuth}
\author{Florian Nehmer}
\date{06.01.2023} % Falls ein bestimmtes Datum eingesetzt werden soll, einfach
                    %  diese Zeile aktivieren.

\begin{document}

\begin{titlepage}% {{{
	\includegraphics[width=6.8cm]{./pic/up-uhh-logo-u-2010-u-farbe-u-rgb.pdf}
	\begin{center}\Large
		\vfill
		Masterarbeit
		\vfill
		\makeatletter
		{\Large\textsf{\textbf{\@title}}\par}
		\makeatother
		\vfill
		vorgelegt von
		\par\bigskip
		\makeatletter
		{\@author} \par
		\makeatother
		Matrikelnummer 6417446 \par
		Studiengang Informatik
		\vfill
		MIN-Fakultät \par
		Fachbereich Informatik
		\vfill
		\makeatletter
		eingereicht am {\@date}
		\makeatother
		\vfill
		Betreuer: Pascal Wichmann, M.\,Sc. Informatik \par
		Erstgutachter: Prof. Dr.-Ing. Hannes Federrath \par
		Zweitgutachter: Pascal Wichmann, M.\,Sc. Informatik.
	\end{center}
	\ifoptionfinal{}{
	\begin{tikzpicture}[remember picture, overlay]
		\node[draw, red, font=\ttfamily\bfseries\Large, xshift=30mm, yshift=238mm,
			rotate=340, text centered, text width=6cm, very thick, rounded
			corners=4mm] at (current page.south) {Entwurf vom \today};
	\end{tikzpicture}
	% ====> Delete me
	\begin{tikzpicture}[overlay]
		\node[draw, blue, font=\sffamily\Large, xshift=0mm, yshift=210mm, rotate=0, text centered, rounded corners=1mm] at (current page.south) {Muster des Deckblatts für Abschlussarbeiten};
	\end{tikzpicture}
	% <==== /Delete me
	}
\end{titlepage}% }}}

\chapter*{Aufgabenstellung}
OAuth [RFC6749] is a widely used authentication protocol, which is typically used between multiple actors, such as different organizations. As authentication is at the core of application security, it is specifically essential to prevent attacks on the authentication.

The tasks of this thesis are as follows: Firstly, a systematic literature study should be performed on existing properties and attacks on the OAuth protocol or its implementations. Secondly, the thesis should design protection strategies for the threats that are not sufficiently solved in existing solutions. Two options for this step are (i) the utilization of anomaly-based intrusion detection for OAuth and (ii) specification-based intrusion detection for OAuth. Thirdly, the thesis should evaluate the security of the designed architecture and compare it to other solutions.

\chapter*{Zusammenfassung}

Für die eilige Leserin bzw. den eiligen Leser sollen auf etwa einer halben, maximal einer Seite die wichtigsten Inhalte, Erkenntnisse, Neuerungen bzw. Ergebnisse der Arbeit beschrieben werden.

Durch eine solche Zusammenfassung (im Engl. auch Abstract genannt) am Anfang der Arbeit wird die Arbeit deutlich aufgewertet. Hier sollte vermittelt werden, warum man die Arbeit lesen sollte.

\tableofcontents

\chapter{Introduction}
\label{chap.introduction}
\section{Motivation}
\todo{Write Motivation}
\section{Research Question}
\todo{Write down Research Question}
\section{Outline}
\todo{Decide if Outline is necessary}

\chapter{Fundamental Knowledge}
\label{chap.fundamental_knowledge}
The OAuth authorization framework is complex and extensive as it has been refined and extended through several standards over the last 11 years. Securing applications using the OAuth protocol, therefore, leads to various considerations. Consequently, section 1 introduces the essential aspects and vocabulary of the OAuth authorization framework in the web context to form an understanding of the security-relevant parts of the protocol.

As one of the main goals of this thesis is to experiment with techniques to detect attacks on services using OAuth, section 2 provides an exploration of intrusion detection systems and the different ways to categorize them.

In the last part of this chapter, section 3 concludes with a description and depiction of the different algorithms used in the experiments.

\section{OAuth 2.0 protocol}
The Open Authorization 2.0 protocol nowadays often referred to as the
\emph{OAuth} protocol, is an authorization framework, that allows third-party
applications to gain limited access to resources in a different location on
behalf of the party, that owns these resources. For many users of the Internet,
it is in practice the protocol behind the ``\emph{Sign in with ...}'' button.
The current standard, first defined in 2012 in RFC6749, is already the
successor of the OAuth 1.0 standard, which was officially published in 2010 by
the IETF in RFC5849 \cite{hammer2010rfc}. In the meantime, several extensions
for the protocol were published as standards and technical reports. These
extensions include new functionalities for the protocol e.g. the ability to use
the protocol with devices like smart TVs and printers \cite{denniss2019oauth}
or documents, which describe several security considerations when implementing
the protocol in practice \cite{lodderstedt2020oauth}. As a whole, the OAuth
working group of the Internet Engineering Task Force (IETF) submitted a total
of 30 Request for Comments (RFCs) and 16 active drafts, from which 7 are active
individual drafts. Table X shows a complete list of all OAuth 2.0. related IETF
submissions by the OAuth working group. 

\subsection{Involved parties}
Because the OAuth protocol is very diverse and complex, as it is a
whole authorization framework it makes sense to narrow it down to its core
features. Starting with the involved parties in the protocol. In general there
are four parties involved in the most common OAuth protocol modes:

\begin{itemize} 

    \item Resource owner: The resource owner is the entity that owns or is
        allowed to manage protected resources. The resource owner might grant
        access to these resources. 

    \item Resource server: The resource server is the server, where the
        protected resources are stored. It can accept or decline authorization
        tokens, which it receives from the client. 

    \item Client: The client is an entity, which makes requests to get access
        to the protected resources, on behalf of the resource owner. 
        
    \item Authorization server: The server, that manages access to the
        protected data. It issues access tokens to the client after successful
        authentication of the resource owner. 

\end{itemize}

Depending on the protocol mode, these four parties or in some cases three
parties exchange different messages in variable ways. In general, there are two
different types of messages, which are explained in the next section.

\subsection{Front-channel and Back-channel messages}

Regarding security considerations messages of the OAuth framework can be
categorized into two main categories, \emph{front-channel} and
\emph{back-channel}. As the protocol is mostly used in the application layer
using HTTP and TLS, \emph{front-channel} means that the message is transported
via the \emph{Request-URI} \cite[Sec. 5.1.2]{fielding1999hypertext} e.g. by
using query parameters. \emph{Back-channel} means on the other hand that the
message is transported via the HTTP message body. In other words, back-channel
messages are transported in one TCP connection, between caller and receiver,
whereas front-channel messages use redirects. \cite[p. 338]{belfaik2022single}.

\subsection{Grant Types}
The protocol flow is dependent on the protocol mode. In the case of OAuth the
different protocol modes are called \emph{Grant types}, as the modes differ on
how the authorization is granted to the resource owner via the client.

\subsubsection{Authorization Code Grant}
According to a recent study, the authorization code grant mode of OAuth is the
most used protocol mode for OAuth on the internet
\cite[Table1]{philippaerts2022oauch}. It is offered by more than 90\% of common 
identity providers.

In this mode illustrated in Figure 2.1, a resource owner aiming to access
protected data via a REST API utilizes a user agent, in this case the web
browser, to interact with a client application that executes API requests
through the user agent. The process begins as the client redirects the user
agent to the authorization server through the front channel. The message
contains a client ID, a redirect URL and a state. The client ID is a unique
identifier of the protected resource. The redirect URI is the location the user
agent is redirected to after authentication. The state can hold any string
value and is most commonly used for CSRF tokens. The authorization server now
asks the resource owner for authentication. If the resource owner is
authenticated and is allowed to access the desired protected resources, the
user agent gets redirected back using the redirect URI. This means that the
message is again sent via the front channel and contains now an authorization
code and the state. Using the valid authorization code and the state, the
client proceeds to request an access token via the back channel at the
authorization server. With the acquired access token the client follows with
the request of the desired protected resource at the resource server.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/authorization_code_grant.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Authorization Code Grant without any extensions}
	\label{fig:auth_code_grant}
\end{figure}

\subsubsection{Implicit Grant}
The Implicit Grant was introduced at a time when there were no mechanisms like Cross-Origin resource sharing implemented in browsers, to share content from different domains. It is a predecessor of the authorization code flow and works similarly with the difference of leaving out the exchanging of the
authorization code step as visualized in figure \ref{fig:implicit_grant}. Instead, the access token is sent via the front
channel directly from the authorization server to the client. This leaves open more attack vectors for example by utilizing the browser history or by
simplifying access token injection \cite{lodderstedt2020oauth}. The Implicit
Grant is officially deprecated, but still has its relevance, as it is still
offered by 37\% of common identity providers \cite{philippaerts2022oauch}.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/implicit_grant.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Implicit Grant}
	\label{fig:implicit_grant}
\end{figure}

\subsubsection{Resource Owner Password Credentials Grant}
This grant type is special in the way that the client is providing its
authentication credentials for the authorization provider to the resource
provider instead, as illustrated in figure \ref{fig:resource_owner_password_credentials_grant}. The resource provider than uses the credentials to retrieve
authorization from the authorization provider. This grant type is only feasible
for the scenario, that the resource provider is trusted completely \cite[Sec.
4.3.]{hardt2012rfc}.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/resource_owner_password_credentials_grant.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Resource Owner Password Credentials Grant}
	\label{fig:resource_owner_password_credentials_grant}
\end{figure}
	

\subsubsection{Client Credentials Grant}
The client credentials grant must only be used by confidential clients
interacting with each other. This means the clients have the ability to
securely store a secret, which is only accessible by themselves. A common
use-case for this scenario would be machine-to-machine interactions. This grant type is meant for clients to access their own resources as is the case in micro-service architectures. As depicted in figure \ref{fig:client_credentials_grant} the client authenticates at the authorization
server with its client secret and receives an access token, to authenticate at the resource provider. This means that the resource provider does not need to verify client secrets, but instead only needs the capability to verify access tokens. This fact is useful for practical reasons, as a resource provider could reuse the implementation of access tokens for other grant types it is offering.
\cite[Sec. 4.4.]{hardt2012rfc}

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.6\textwidth]{pic/client_credentials_grant.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Client Credentials Grant}
	\label{fig:client_credentials_grant}
\end{figure}

\subsubsection{Device Authorization Grant}
Introduced in RFC8628 the device authorization grant is meant to be used for
devices, that lack a user agent like a web browser or do not offer a convenient
way of entering text \cite{denniss2019oauth}. In this grant type the client is
not mainly interacting through a user agent like a web browser anymore, but instead is using a device authorization endpoint at authorization provider directly to initiate an authorization request. The client, then instructs the user to open a webpage on a secondary device to complete the authorization process using a displayed code for verification of the session. This OAuth flow still requires the involved devices to use HTTP for communication, which in general is not a feasible solution for many IoT-devices. A solution for the popular IoT-protocol CoAP is proposed by Chung et al. 

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/device_authorization_grant.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Device Authorization Grant}
	\label{fig:device_authorization_grant}
\end{figure}

\subsubsection{Other grant types}
There are several more grant types, which got introduced to the OAuth standard
over time, which are listed below, but are out of scope for this work: 

\begin{itemize}
	\item Refresh Token Grant
	\item JWT Bearer Grant
	\item UMA Grant
	\item SAML 2.0 Bearer Grant
	\item Token Exchange Grant
\end{itemize}

\subsection{Open ID Connect}
Open ID Connect (OIDC) is a layer on top of OAuth 2.0, introduced in 2014 by a combination of researchers and companies like Google, Microsoft and Salesforce, which form the OpenID group. The main focus of Open ID Connect is authentication, which means identifying a user but not authorizing the user. OIDC flows use a particular OAuth scope, which is called "openid", an extra token, the "ID token", which is a JWT token containing the identifying information about the user, which are called claims. The claims can be used to retrieve more information about the user at the OpenID provider, or the information can be directly part of the initial ID token, so OpenID adds the authentication to the already provided Authorization capability of OAuth. For OIDC, the same grants are used as for OAuth, but in the context of OIDC, they are often referred to as flows \cite{li2016analysing} \cite{sakimura2014openid}.

\subsection{The Future: OAuth 2.1}
OAuth 2.1 will be the next version of OAuth. There is currently one draft available at the IETF \cite{ietf-oauth-v2-1-09}. The main intent of this draft is to consolidate the various extensions to OAuth introduced in the last years. It simplifies the core document for OAuth 2.0 and omits outdated features because of new browser capabilities, which came over the last years and allow for more secure interactions. Below is a list of significant changes:
\begin{itemize}
	\item The Implicit Grant gets omitted
	\item The Resource Owner Password Credentials Grant gets omitted
	\item PKCE is required for the Authorization Code Grant
	\item Redirect URIs must be compared with exact string matching, so pattern matching is completely disallowed
	\item Access tokens must not be transported in a Request-URI in any case (which also makes the Implicit Grant impossible
\end{itemize}

In conclusion, the draft for OAuth 2.1 picks valuable features of existing standards for OAuth to require them and omits outdated features, intending, on the one hand, to simplify the OAuth landscape and, on the other hand, get rid of insecure features of the past.

\section{Intrusion Detection System}
\todo{Fundamental Knowledge: Make clearer that the long definitions use one source}
An intrusion is any malicious behavior with the intention to damage or take control of an information system. All primary protection goals of information security, like confidentiality, integrity and availability, can be the target of an intrusion. A method to harden systems against intrusions is using intrusion detection systems (IDS), which monitor all traffic, events or actions of a system to detect when malicious actions are executed so the system's owner, the administrator or the system itself can take immediate action on intrusion attempts. If the intrusion detection system takes action to prevent intrusions, it is called an \emph{Intrusion Detection and Prevention System (IDPS)} \cite{scarfone2010intrusion}. There are several taxonomies for intrusion detection system types. For example, \cite{Liao2013IntrusionDS} categorized IDS into five categories: Statistics-based, Pattern-based, Rule-based, State-based, and Heuristic-based, referring to the methodology of detection the IDS is using. \cite{khraisat2019survey} build on top of that approach to further specify an overall taxonomy for IDS, which is used in this work to define Intrusion Detection Systems. 

\subsection{Distinction by input data}
Generally, when categorizing Intrusion Detection Systems by environment or input data, there are two types to distinguish them. 
\emph{Host-based Intrusion Detection Systems (HIDS)} and \emph{Network-based Intrusion Detection Systems (NIDS)}.
\subsubsection{Host-based Intrusion Detection System}
HIDS monitor all data concerning a host system, like operating system events, host firewall logs or application-specific logs. They can detect specific attacks on the system level without using network logs.
\subsubsection{Network Intrusion Detection System (NIDS)}
NIDS monitor network traffic, which is acquired by packet capture tools and other network data sources. One challenge of Network Intrusion Detection Systems is often the large amount of data that needs to be analyzed in high-bandwidth networks, which demands high computing capabilities.

\subsection{Distinction by detection characteristic}
When distinguishing types of intrusion detection systems by the way they operate, there are two categories: Signature-based (SIDS) and Anomaly-based (AIDS).

\subsubsection{Signature-based Intrusion Detection System}
Signature-based IDS utilize databases of fingerprints of already known attacks. These databases are called knowledge databases. A fingerprint could be, for example, a hash value of an executable malware file. A HIDS could compare any file an operating system executes against the knowledge database to detect the specific malware. The same concept also works for NIDS, e.g., when scanning mail attachments transferred via SMTP. The main advantage of SIDS is that they rarely produce false positive alerts when identifying intrusions. Their downside is that they cannot detect unknown attacks.

\subsubsection{Anomaly-based Intrusion Detection System}
The core concept for Anomaly-based IDS is to differentiate between usual and unusual behaviour. Unusual behaviour is identified as an intrusion. There is a variety of techniques that AIDS can use to achieve the goal of differentiating typical and malicious behaviour. One possibility is creating a statistical model over the data and filtering out events with a low probability. 
Another approach is to use machine learning techniques. Unsupervised learning methods, like clustering, on the one hand, are very similar to the statistical approach because the goal is again to sort out rare occurrences in small clusters. Supervised learning methods, on the other hand, create a model of usual behaviour in a training phase with labelled data to test any new input of unknown data if it is classified as malicious. 
An additional way for Anomaly-based IDS is the knowledge-based method. With this method, knowledge is applied to the detection in the form of rules to identify any behaviour that breaks those rules as an intrusion. These rules can stem from knowledge about a network protocol or any other system behaviour.

\subsection{zeek IDS}
\emph{Zeek} formerly known as \emph{bro}, as a reference to George Orwell's 1984 as a ``reminder that monitoring comes hand in hand with the potential for privacy violations'' \cite{zeek2023} is an open source network intrusion detection system. The first version of \emph{bro} was released in 1995 by the Lawrence Berkeley National Laboratory. In 2018, the project was renamed to \emph{zeek}. The system is often used for network security monitoring to detect and analyze suspicious behaviour in network traffic. Its architecture consists of two major components, as displayed in Figure. The first component is the \emph{event engine}, which refines the incoming network traffic into higher-level events without doing any analysis. It processes the traffic through different subcomponents, identifying protocols, file types, and, e.g. TCP connections at the link layer. The second component is the \emph{policy script interpreter}, which runs different event handlers to analyze the events. These event handlers are built in their own scripting language, but adaptors to public programming languages also exist and are applied in this work.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/zeek_architecture.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Architecture of zeek \cite{zeek2023}}
	\label{fig:zeek_architecture}
\end{figure}

\section{Algorithms}
\subsection{k-Means Clustering}
In the field of data analysis, finding patterns and anomalies in data sets is a ubiquitous challenge. Grouping data into different clusters can be an approach to reveal useful features or meanings from the data. One common technique for clustering is k-means clustering. There are different flavors of k-means algorithms, but one of the most common k-means algorithms and the one applied in this work is Lloyd's k-means algorithm \cite{wilkin2007kmeans}. 
\subsubsection{Lloyd's k-Means clustering}
The general goal of the algorithm is to group data by similar features into a fixed amount of clusters. The algorithm achieves this by finding $k$ \emph{centroids} $\mu_1, \mu_2 ... \mu_k \in \mathbb{R}$. The clusters are then based on the centroids so that every point $x$ of the n-dimensional dataset ${x_1 ... x_m}$ gets assigned to the centroid with the lowest Euclidean distance. In order to find the centroids, the algorithm's approach is an iterative process described in figure \ref{fig:kmeans}. In the beginning, $k$ (defined by the number of clusters) random centroids are chosen. Then, the clusters are created by calculating the minimum Euclidean distance from every point of the dataset to the centroids: $\arg\min_j \|x_i - c_j\|^2$. In the next step, the centroids are recalculated by finding the points in the center of the clusters: $\mu_j = \frac{1}{|\mu_j|} \sum_{x_i \in \mu_j} x_i$. The two steps of creating the clusters based on the centroids and calculating the center point of the new clusters are repeated until the centroids converge or a definition for a fixed amount of iterations is given \cite{piech2013kmeans} \cite{lloyd1982kmeans}.



\begin{algorithm}
	\label{fig:kmeans}
	\caption{Lloyd's K-Means Algorithm}
	\begin{algorithmic}[1]
		\State \textbf{Input:} Data set $X = {x_1 \ldots x_m}$, number of clusters $k$
		\State \textbf{Output:} Cluster centroids $\{\mu_1, \mu_2, \ldots, \mu_k\}$
		\State Randomly choose $k$ centroids ${\mu_1 \ldots \mu_k}$ 
		\Repeat
		\For{each data point $x_i$}
			\State Assign $x_i$ to the cluster with the nearest centroid: $\mu_i = \arg\min_j \|x_i - \mu_j\|^2$
		\EndFor
		\For{each cluster $j$}
			\State Calculate new centroid $\mu_j$ as the center of all points assigned to cluster $j$ for every cluster: $\mu_j = \frac{1}{|\mu_j|} \sum_{x_i \in \mu_j} x_i$
		\EndFor
		\Until{New centroids don't change anymore or a fixed number of iterations was given}
	\end{algorithmic}
\end{algorithm}
\todo{Adjust with stanford formulas}
	
\subsection{Word2Vec}


\emph{Word2Vec} introduced in 2013 by Mikolov et al. is a technique in natural language processing to convert words into embeddings. An embedding is a vector carrying a semantic to represent a word as a numerical value to enable the usage of words in algorithms requiring numerical inputs. In the case of \emph{Word2Vec}, the idea is that words hold similarities based on their surrounding words in a text corpus. This concept leads to words, which often stand close together in a text, receiving vectors that point in a similar direction. There are two models which are employed by \emph{word2vec}, the \emph{Continous Bag of words (CBOW)} model and the \emph{Skip-Gram} model. Both models have in common that they apply supervised learning techniques by training a neural network to predict relationships in text corpora. In both cases, the goal is to use the weights of the hidden layer after training as word embeddings instead of utilizing the neural networks for any predictions \cite{mikolov2013efficient} \cite{rong2014word2vec}.

\subsubsection{Continous Bag of Words (CBOW)}
The continuous bag of words model trains a neural network that predicts the word in the middle based on its surrounding words. An important hyperparameter for CBOW and Skip-Gram is the window size, which describes how many words surrounding a word are considered context. 
During training, the network receives combined one-hot-encoded vectors of surrounding words (e.g., averaging or summing them) in a tuple with the corresponding target word. When the training is completed at inference, the model gets context words as input and outputs a vector of probabilities for the predicted target word. But as mentioned above, the goal of word2vec is to extract word embeddings, which are the weights of the hidden layer of the neural network.

\subsubsection{Skip-Gram}
The skip-gram model uses the reverse strategy compared to the CBOW model. Instead of predicting a word by its surroundings, it trains a neural network that tries to predict the surroundings of a word. At training, the neural network receives word tuples of single context words and their corresponding target words one-hot-encoded. After fitting the network during inference, the model receives a one-hot-encoded word as input and produces a probability distribution over the vocabulary, which stands for the probability of a word being a surrounding word for the input. Again, in the case of word2vec, this supervised learning approach is only applied to retrieve the weights of the hidden layer as word embeddings, as word2vec is used for non-labelled data. In their research, Mikolov et al. state that skip-gram is feasible for small data sets and even considers rare occurrences of words well. In contrast, CBOW is faster in training with large datasets and better at capturing the semantics of high-frequency words. 

% \subsection{k-nearest neighbor}

\chapter{Related Work}
\label{chap:related_work}
This chapter presents important research in the realm of OAuth security and intrusion detection using similar techniques as proposed in this work. As this thesis first builds a strong foundation in OAuth threads and vulnerabilities, Section \ref{sec:fks_model} starts by presenting an important publication in the realm of theoretical analysis of OAuth by Fett et al..

Section 

\todo{Continue Introduction to Related Work chapter}
\section{Theoretical Security Analysis of OAuth}
\label{sec:fks_model}
??


\cite{fett2016comprehensive}
\todo{Realted Work: Describe Security Analysis of OAuth}

\section{Machine Learning approach to detect OAuth vulnerabilities}
\cite{munonye2022machine}
\todo{Related Work: Describe approach to detect OAuth vulnerabilities}
\section{Another One}
\todo{Related Work: Decide on which 1-2 more articles to mention here aswell}


\chapter{OAuth Security}

This chapter presents known threats and vulnerabilities when using the OAuth authorization framework. Section \ref{sec:oauth_threats_and_vulns} elaborates on every threat and vulnerability separately. The list is mainly based on the current draft for security best practices for OAuth from the OAuth task force at IETF and is enriched with various examples, further explanations, and a categorization of types of threats.

Section \ref{sec:oauth_countermeasures} starts with a classification of OAuth threats and vulnerabilities by mitigation responsibility of the involved parties in the protocol. It then continues with a description of the specific countermeasures and mitigation strategies and ends with an overview of which threat can be mitigated by which countermeasure.

Lastly, section \ref{sec:discussion_of_oauth_security} performs a short discussion about the difference. \todo{Finish this when there is an idea for section 3}

\section{Threats and Vulnerabilities}
\label{sec:oauth_threats_and_vulns}

\subsection{Insufficient Redirect URI Validation \cite{lodderstedt2020oauth} \cite{wang2019make}}
Authorization Servers need to whitelist redirection URLs in order to make sure,
that an attacker cannot craft a hyperlink, which leads to the victim initiating
an OAuth flow and sending the authorization code or token to an
attacker-controlled domain. Some authorization servers may allow the usage of
patterns in order to allow several domains at once. As well as the absence of
any sort of whitelist mechanism even a pattern-matching functionality could
lead to security problems. Among the possibility that a user is entering
patterns that are too broad and allow the usage of unintended redirect URLs,
the attack surface includes issues with the URL parsing implemented by the
authorization server as shown by Wang et al. \cite{wang2019make}. They
presented several techniques to trick the parser into accepting unintended
domain names, like using squared brackets for IPv6 parsing or the \emph{Evil
Slash Trick}, where the parser does not treat a forward slash as a path
separator, while modern browsers do. Depending on the OAuth grant type in use
this vulnerability leads to different possibilities to exploit it.


\subsubsection{Authorization Code Flow}
\begin{itemize}

    \item The attacker uses techniques like phishing to make its victim open an
        attacker-controlled webpage, which initiates an OAuth flow with the
        vulnerable authorization server.
	
    \item The request is crafted with a valid client ID (which is public
        information), ``code'' as response type and a malicious redirect URI,
        which leads to an attacker-controlled server again.
	
    \item If the user logs in at the authorization server, the authorization
        code now gets transmitted to the attacker's webpage, via the redirect
        URI.
	
    \item The attacker page can now use the received authorization code, to
        retrieve a token 

\end{itemize}

\subsubsection{Implicit Flow}
\todo{Maybe write down open redirection with the implicit flow here regarding redirect\_uri check circumvention}


\subsection{Credential Leakage via Referer Headers}
\label{subsec:cred_leak_ref_headers}
The Referer HTTP header is a potential attack surface. It can be utilized by a
malicious actor to capture query parameters, which are sent via the front
channel, like the state and the authorization code. The authorization code may
be used to redeem an access token before the victim retrieves it and the state
parameter oftentimes includes a CSRF token, which could potentially open up
vulnerabilities in other parts of the application as explained by Fett et al
\cite{fett2016comprehensive}.

\subsubsection{OAuth Client}
If a client renders third-party content, like advertisements in iframes or
images, before redeeming the authorization code for an access token an
attacker, who places these advertisements or images can capture the code via
the referer header and redeem it for an access token.

\subsubsection{Authorization Server}
At the authorization server, the state parameter could be leaked via the
Referer header, when third-party images or advertisements are being rendered on
the page. This may be an issue when the state contains a CSRF token as
explained by Fett at al \cite{fett2016comprehensive}.


\subsection{Credential Leakage via History Logs}
\label{subsec:cred_leak_browser_history}
OAuth potentially transports sensitive data via the request-URI, like the access token, as is the case when the implicit grant is used or if other grant types optionally allow the transportation of access tokens or authorization codes via URI parameters. Therefore, a person accessing the user's browser can extract this sensitive data and try to replay it. The same threat is present when a logging server is present, for example, in a corporate network \cite{lodderstedt2020oauth}. Research about browser history security focuses mainly on accessing information about the victim's history by comparing cache timings if a page was visited \cite{bansalcache}. This type of threat is irrelevant in the OAuth context because an attacker would need to guess the access token, which the attacker could endeavor outside the browser history as well. However, recent studies on the security of browser extensions show that malicious browser extensions could access the browser history, or data could be leaked by utilizing vulnerable browser extensions \cite{eriksson2022}.

\subsection{Mix-Up Attack}
\label{subsec:mix_up}
In this attack, at least two authorization providers are involved. The target AP and the attacker AP. The OAuth standard allows the resource provider to interact with multiple authorization providers, one of which could be malicious, so the security for such interactions must also be provided. The attack is feasible for the implicit and authorization code grants and works similarly for both. Another precondition is that the resource owner registers the same redirect URI at both authorization providers, which is typical for Open ID Connect dynamic client registration \cite{hosseyni2023formal}. With these preconditions present, the attacker now waits until the target initializes an OAuth flow with the attacker AP. The attacker then intercepts the initialization request and exchanges the target AP with its attacker AP. When the target client gets redirected to the attacker AP, the target gets immediately redirected back to the target AP for authentication. At the same time, the client ID in the query parameters of the redirection URL gets replaced with the one registered at the target AP. Suppose the target user authenticates because it did not detect that it intended to authenticate at another AP. In that case, an authorization code gets issued to the client when the authorization code grant used. The client then proceeds to try to redeem an access token at the attacker AP, as the client still thinks that it initiated an OAuth flow with the attacker AP. The attacker can now use the received authorization code to redeem an access token at the target AP. \cite{fett2016comprehensive}

\subsection{Authorization Code Injection \cite{philippaerts2022oauch}} 
The precondition for an authorization code injection is that an attacker has
successfully stolen an authorization code. This can be accomplished in various
ways for example by tricking the user into installing a malicious browser
extension, using other vulnerabilities in a web app like open redirections, or
abusing proxy auto-configuration files \cite*{philippaerts2022oauch}.

In the case, that the client is using the authorization code flow the attacker
can use the stolen authorization code to fetch an access token before the
client does.

\subsection{Access Token Injection}
This kind of attack describes the process of an attacker using a stolen access
token in a legitimate authentication flow, to impersonate the client. If the
implicit flow is available, the attacker can now start a new flow and simply
replace the access token in the authorization servers' response. This will
circumvent any CSRF protection, as there is no difference to a non-compromised
flow. \cite{lodderstedt2020oauth}


\subsection{Cross Site Request Forgery}
\label{subsec:csrf}
This type of attack, often referred to by its abbreviation ``CSRF"", is about
the attacker executing a request in the name of the user, by tricking the user
into executing requests for the attacker including all required authentication,
or authorization information. The default OAuth protocol does not include
protection mechanisms against this type of attack. 

\subsection{PKCE Downgrade Attacks}
If an authorization server is not implemented to require PKCE for all its
flows, it is susceptible to being vulnerable to PKCE downgrade attacks
\cite{philippaerts2022oauch}. Even if it is documented otherwise, attackers
might try to omit PKCE parameters, as the current OAuth 2.0 standard does not
require the usage of the PKCE extension \cite{hardt2012rfc}. 


\subsection{Access Token Leakage at the Ressource Server}
In the scenario that clients can dynamically connect to resource servers at runtime, as is the case in mail or banking applications, an attacker could create a malicious resource server and trick the user into sending valid access tokens for the target data to the malicious resource server. It could also be the case that the client application is misconfigured to send access tokens to a dynamically created resource server. Another vector for Access token leakage at the resource server is when the server itself gets compromised, so the attacker receives access tokens by analysing connections to the server itself \cite{lodderstedt2020oauth}.

\subsection{307 Redirect}
\label{subsec:307}
The OAuth standard does not specify which type of HTTP redirect should be implemented to redirect the user back to the client after the authentication at the authorization provider is successful. As the HTTP 307 redirect reuses the header and the body of the original request \cite{fielding1999rfc2616}, a malicious client could extract the username and password of the initial form submission action because it receives this data as part of the redirection \cite{fett2016comprehensive}.

\subsection{Client Impersonating Resource Owner}
\label{subsec:client_impers_res_own}
In the scenario that an authorization server allows for multiple grant types, including the client credentials grant and another typical grant like the authorization code grant, the threat of a malicious client impersonating a resource owner can be present in certain implementations. One example is when the authorization server allows for dynamic registration of clients, with the possibility of setting a client ID. A client could set its ID to the value of an identifying value of a resource owner. To build the example further, Open ID Connect uses a token's subject property to identify a user \cite{sakimura2014openid}. A client could use the subject value as its client ID. Improper implementations of resource servers, which do not distinguish between token types by grant type, could mistake an access token issued to a resource owner with a token issued to a client, which allows the malicious client to access the protected data of the resource owner \cite{lodderstedt2020oauth}.


\subsection{Authorization Server Redirecting to Phishing Site}
\label{sub:authorization_server_redirecting_to_phishing_site}
When the authorization server allows dynamic client registration, an attacker could create a valid client to which the authorization server could redirect. The attacker then crafts a malicious authorization request that will always fail by appending an invalid \emph{scope} value and then will redirect to the phishing site. An example of such a malicious authorization request is depicted in Figure \ref{fig:phishing_requests}. As the authorization attempt using this crafted URL is always invalid because of the \emph{scope}, the victim immediately gets redirected back to the site given by the \emph{redirect\_uri} parameter, which legally got enlisted through dynamic client registration. This site could be a copy of the valid login page to trick the user into entering its credentials. This way of phishing is very subtle as the domain of the phishing link is valid and known by the victim. The victim would need to identify that the \emph{redirect\_uri} query parameter is invalid and realize that it gets redirected to this URL after clicking on the link with the valid domain \cite{lodderstedt2020oauth}.


\begin{figure}[ht]
	\sffamily\footnotesize
	\url{https://valid-site.com/authorize?scope=invalid&redirect_uri=https://phishing-site.com/login&client_id=client_id_of_malicious_client}
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Phishing request}
	\label{fig:phishing_requests}
\end{figure}

\subsection{Unvalidated Redirects and Forwards}
\label{subsec:open_redirect}
This type of vulnerability, known as \emph{Unvalidated Redirects and Forwards} (URF) as well as \emph{Open Redirect}, exists when a web application exposes redirection or forward capabilities to untrusted user input, for example, through query parameters. An attacker could generally utilize URF vulnerabilities to craft phishing links that are masked with valid, trustworthy domains \cite{wang2015urfds}. Especially in connection with OAuth, an attacker using an existing URF vulnerability in a client can potentially circumvent whitelists for redirection URIs, by masking the redirect to a malicious client with a valid client exposing an open redirect in the query parameter \cite{lodderstedt2020oauth}. Section \ref{sub:authorization_server_redirecting_to_phishing_site} describes a different attack aimed at masking a phishing attack utilizing a mechanism specific to OAuth that is similar to an open redirection at the authorization server and therefore a threat, which is introduced by the implementation of OAuth itself.

\subsection{Clickjacking}
\label{subsec:clickjacking}
As authorization providers authorize applications to access confidential data, they are susceptible to being targeted by clickjacking attacks. Clickjacking attacks trick users into performing clicks on elements on a web page the users did not intend to interact with, e.g., by overlaying invisible iframes. In the case of OAuth, an attacker could create a malicious application and register it at the authorization provider of the target. The attacker also prepares a webpage that tricks the user into clicking on an invisible iframe of the authorization provider. The iframe could contain the grant access step of allowing the malicious application to access the user's confidential data. If the user has an active session at the authorization provider, a single click is enough to fulfill this action \cite{gibbons2014security}. 


\section{Countermeasures}
\label{sec:oauth_countermeasures}
\subsection{Mandatory PKCE}
As an extension to OAuth defined by RFC 7636, \emph{Proof Key for Code Exchange (PKCE)} is a technique to mitigate several OAuth threats \cite{bradley2015rfc}. The main problem PKCE solves for the authorization code grant is verifying that only the original client who started an OAuth flow receives the access token, so a stolen authorization code cannot just get exchanged with an access token by the entity who stole the code. Figure \ref{fig:pkce} shows the way PKCE works \cite{siriwardena_oauth_2020}:

\begin{enumerate}
	\item Initially, before the client redirects the resource owner\'s user agent to the authorization server, it generates a random string of length 43 at minimum, called the \emph{code\_verifier}. It then calculates the hash value of the code\_verifier and encodes it with base64 without padding. The hash algorithm in use should be one which is currently regarded as secure and known by the authorization server. The resulting value is called the \emph{code\_challenge}
	
	\item At redirection to the authorization server, the client appends the code\_challenge and the hashing algorithm, which it has used to create the code\_challenge to the redirection URL as query parameters.
	
	\item After successful authentication, the authorization server creates a record of code\_challenge and the corresponding authorization code it generates and sends back to the user agent. Alternatively, it may append the code\_challenge to the authorization code and create the record this way.
	
	\item When exchanging the authorization code for an access token, the client sends the code and the code\_verifier to the authorization server.

	\item The client compares the code\_verifier with the corresponding code\_challenge of the authorization code by calculating the unpadded base64 encoded hash value of the provided code\_verifier. Only the client who initially requested protected resources could possess the random value that matches the code\_challenge.
\end{enumerate}


The PKCE mechanism mitigates several threats and vulnerabilities, as shown in Table X. It mitigates credential leakage via referer headers (T2), as this attack aims in the case of the authorization grant to extract authorization codes after a redirect. Even with a stolen authorization code, an attacker does not know the code\_verifier and thus can not receive an access token. For the same reason, any kind of authorization code injection (T5), where the precondition is a stolen authorization code, would only be possible by knowing the code\_verifier. Protection against cross-site request forgery (T7) is also provided since an attacker could not trick a client into appending confidential data to the resources owned by the attacker, as the victim\'s client does not send the attacker\'s code\_verifier to the authorization server. Lastly, protection against PKCE downgrade attacks (T8) is ensured when the authorization server implements PKCE as mandatory.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.75\textwidth]{pic/PKCE.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Authorization Code Grant with extension for Proof Key for Code Exchange}
	\label{fig:pkce}
\end{figure}

\subsection{Random value state}
\label{sec:countermeasure:state}
Another method to protect against Cross-Site request forgery is by taking advantage of the state parameter the OAuth standard offers. When the client initiates an authorization request, it generates a random value of sufficient length, attaches it to the current session and sets it as the state parameter for the request. After authentication, the authorization server has to attach the previously received state parameter to the redirection URI as a query parameter. The client can now validate the received state value with the one it attached to its session earlier to ensure the redirection stems from the authorization flow it initiated \cite{ferry2015security}. When PKCE for the authorization code grant is already implemented, this measure does not add any benefit regarding CSRF protection \cite{bradley2015rfc}. In conclusion, the usages of state's main difference to PKCE is that the client knows that the received authorization code is connected to its initial authorization request before redeeming an access token with the code\_verifier, where the authorization server relates the client's requests to each other with the code\_challenge and the code\_verifier.


\subsection{Invalidation of access tokens}
The OAuth framework requires an authorization code to be redeemed only once for an access token. Therefore, an authorization code needs to be invalidated after its first usage. However, this does not stop an attacker from receiving an access token with a stolen authorization code before the valid user does it. The original OAuth standard recommends invalidating a previous access token if there was an attempt to receive an access token at least twice for the same authorization code \cite{hardt2012rfc}. Invalidation of access tokens if an authorization code gets redeemed twice helps mitigate the threats of credential leakage via referer headers (T2) and credential leakage via browser history (T3) \cite{lodderstedt2020oauth}, as for these threats, exposed authorization codes were already redeemed in most cases.

\subsection{Simple string comparision}
A technique to completely circumvent the threat of insufficient redirect URI validation (T1) is to disallow whitelisting redirect URIs using regular expressions. Instead, exact string comparison should be the way to allow redirections \cite{lodderstedt2020oauth}.

\subsection{Avoid usage of grant types}
Threats like credential leakage via referer headers (T2) or browser history (T3) can be avoided when the implicit grant is not used at all, as the access token would not be in the URI of a request. Access token injection (T6) using the implicit grant makes it easy for any attacker to circumvent CSRF protection through the state parameter (see Section \ref{sec:countermeasure:state}) since, for the client, it does not make a difference what access token is used for the state check \cite{lodderstedt2020oauth}. For these reasons, the OAuth task force removed the implicit grant in the draft for OAuth 2.1 \cite{hardt2023rfc}. In the past the main benefit of the implicit flow was that it was possible to implement it for clients that did not utilize cross-origin resource sharing (CORS). CORS was finalized in 2014 by the W3C and superseded by the fetch standard afterwards \cite{vanKesteren2014}. As the OAuth standard dates back to 2012 \cite{hardt2012rfc}, the implicit grant could be implemented for applications that did not support CORS yet.

\subsection{Constrained access tokens}
This countermeasure aims to harden the protocol against the misuse of stolen access tokens if they are leaked, for example, at the resource server (T9) or through credential leakage via the browser history (T3) and or referer headers (T2). It reaches this goal by narrowing the access permissions of the access token in two ways \cite{lodderstedt2020oauth}:
\begin{itemize}
	\item \emph{Sender-constrained access token}: The token contains cryptographical material to identify the client who redeems the access token, which opens the possibility of only allowing specific clients.
	\item \emph{Audience-constrained access token}: Access tokens are constrained to particular resource servers. The resource owner executes the audience configuration at the resource server, and the resource server performs the audience verification. If the access token, in addition, bears user-identifying data, different audiences can be defined at the resource server level to further restrain access to the protected data.
\end{itemize}

 
\subsection{Issuer identification}
Per default, the OAuth authorization grants do not include mechanisms for clients to identify an authorization server, which sends them an authorization response through redirection. This circumstance leads to threats like Mix-Up attacks (T4), when multiple authorization servers are involved. Issuer identification has been introduced to tackle this issue with RFC9207 in 2022. The issuer identifier \emph {iss} is a parameter which must be sent to the client in every response, even if it is an error response. The \emph{iss} parameter contains the URL, which points to the metadata of the authorization server. This metadata has to include an ``issuer'' property, which contains a value identical to the value of the \emph{iss} property. The client, which supports issuer identification, has to store the identifier locally when initiating an interaction with an authorization server. The client then must compare the stored value with the one it receives from the authorization response with a simple string comparison. The client is also responsible for ensuring that every authorization server it interacts with holds a unique issuer identifier \cite{meyer2022rfc}.


\subsection{Implementation details}

There are several countermeasures that one can categorize as implementation details, as they are applied through small decisions during client or authorization server implementation. The following is a brief list of these measures as suggested by Lodderstedt et al. \cite{lodderstedt2020oauth} and the classification of which involved party is responsible for implementing the measure.
\begin{itemize}

\item \emph{303 redirect}: As mentioned in \ref{subsec:307}, the OAuth standard does not mandate the type of HTTP redirect to use for authorization servers. To circumvent issues with improper redirect handling leading to security issues, the authorization server should use 303 redirects.

\item \emph{Client\_ID not choosable by user}: To mitigate threats that arise through the possibility of a client choosing its own client ID, as described in \ref{subsec:client_impers_res_own}, the client ID should always be chosen at random by the authorization server, where the clients are getting registered.

\item \emph{No redirect before authentication at authorization provider}: Some threats arise because authorization servers might be implemented in a way that they are redirecting the user agent in error cases, even without complying with the redirect URI whitelists in some cases. This behaviour could lead to advanced phishing attacks described in \ref{subsec:mix_up}. Therefore, authorization servers should be implemented in a way that they only redirect the user agent if the authentication of the resource owner has been successful.

\item \emph{No access token in uri}: The OAuth standard allows for access tokens to be transported in the request URI from the client to the authorization server when accessing protected data. This option leads to threats concerning leakage of the access token through browser history \ref{subsec:cred_leak_browser_history} or referer headers \ref{subsec:cred_leak_ref_headers}. Therefore, an authorization server should implement the transporting of the access token through a request body as mandatory.

\item \emph{Avoid third-party content on pages involved with OAuth}:
\label{item:avoid3rd}
Malicious advertisements in iframes or attacker-generated hyperlinks on pages an OAuth flow redirects to could lead to leakage of access tokens or authorization codes through referer headers \ref{subsec:cred_leak_ref_headers}. Therefore, authorization servers and clients must ensure that no third-party content is allowed for the redirection endpoint at the client and authentication page at the authorization server.

\item \emph{Appropriate Referer Policy}: On top of the measure described above about rendering of third-party content, to mitigate credential leakage via referer headers, an appropriate referer header policy should be implemented like the ``Referrer-Policy: no-referrer'' header in authorization requests or as a meta tag in HTML documents.

\end{itemize}

\subsection{General web security countermeasures}
After laying out several mitigations for attack vectors of OAuth, there are still general web security threats, which are especially important for OAuth, like clickjacking \ref{subsec:clickjacking}, open redirections \ref{subsec:open_redirect} or CSRF \ref{subsec:csrf}. The reason why these common web security vulnerabilities are critical in the case of OAuth has been laid out in their specific sections. The countermeasures for those types of vulnerabilities, however, are very context-specific and are out of the scope of this work. Hence, in further portrayals of threats and countermeasures in this work, they are described as countermeasures against clickjacking, open redirect and CSRF, but do not include specifics.

\section{Classification of OAuth threats and vulnerabilities}
The OAuth authorization framework tries to solve a lot of practical authorization use cases at once and, therefore, offers a very flexible and diverse set of definitions for such use cases. Hence, it follows that the threat space and attack vectors are also complex and diverse, as laid out in the previous two sections \ref{} and \ref{}. To facilitate a general, more tangible overview of the threat situation of OAuth, this work presents a brief taxonomy based on the perspective of the involved parties.

\subsection{Encoding of threats, vulnerabilities and countermeasures}
To improve the visibility in tables for the following depictions the OAuth threats and vulnerabilities are encoded with the following scheme:
\begin{itemize}
	\item TV1: Insufficient Redirect URI Validation
	\item TV2: Credential Leakage via Referer Headers
	\item TV3: Credential Leakage via Browser History
	\item TV4: Mix-Up Attacks
	\item TV5: Authorization Code Injection
	\item TV6: Access Token Injection
	\item TV7: Cross-Site Request Forgery
	\item TV8: PKCE Downgrade Attack
	\item TV9: Access Token Leakage at the Resource Server
	\item TV10: 307 Redirect
	\item TV11: Client Impersonating Resource Owner
	\item TV12: Authorization Server Redirecting to Phishing Site
	\item TV13: Unvalidated Redirects and Forwards
	\item TV14: Clickjacking
\end{itemize}

for the same reason, the countermeasures are encoded as well using the following scheme:

\begin{itemize}
	\item C1: Mandatory PKCE
	\item C2: Random value state
	\item C3: Invalidation of access tokens
	\item C4: Invalidation of state value
	\item C5: Simple String comparison
	\item C6: Avoid usage of grant types
	\item C7: Sender Constraint Access Token
	\item C8: Audience Constrained Access Token
	\item C9: Issuer identification
	\item C10: 303 Redirect
	\item C11: Not choosable client\_ID
	\item C12: No redirect before authentication
	\item C13: No access token in URI
	\item C14: No third-party content on pages involved with OAuth
	\item C15: Appropriate Referer Policy
	\item C16: Open redirection countermeasures
	\item C17: Clickjacking countermeasures
\end{itemize}

Non-encoded versions of the tables are added to the appendix and referenced from the encoded versions of the tables.

\subsection{Threats and their countermeasures}

The first classification displayed in figure \ref{tab:txc} is visualizing, which countermeasure mitigates aspects of which threat or vulnerability. 

\begin{table}[!ht]
    \centering
	\caption{CXT}
	\label{tab:txc}
	\setlength\tabcolsep{1.5pt}
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
    \hline
        ~ & \rot{Maybe like this?} & C2 & C3 & C4 & C5 & C6 & C7 & C8 & C9 & C10 & C11 & C12 & C13 & C14 & C15 & C16 & C17 \\ \hline
        TV1 & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ \\ \hline
        TV2 & x & ~ & x & x & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & x & ~ & ~ \\ \hline
        TV3 & ~ & ~ & x & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ \\ \hline
        TV4 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV5 & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV6 & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV7 & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV8 & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV9 & ~ & ~ & ~ & ~ & ~ & ~ & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV10 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV11 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV12 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ \\ \hline
        TV13 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ \\ \hline
        TV14 & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x \\ \hline
    \end{tabular}
\end{table}

\chapter{Experimental Analysis}
\label{chap:exp}
This chapter examines the capabilities of the intrusion detection techniques and algorithms presented in chapter \ref{chap:exp}.

Initially, section \ref{sec:exp_setup} describes generally the structure of the experimental environment for dataset generation and analysis. This section is subdivided into three parts to describe the multi-step process that was implemented to generate and analyze datasets for the experiments.

\section{Implementation of the experiment environment}
\label{sec:exp_setup}

An essential piece for this research and its experiments is a complete testing environment for OAuth as at the time of this writing a dataset of network logs with specific attacks on OAuth does not exist. To generate a dataset to analyze it, an experimental environment was implemented containing multiple components as illustrated in figure \ref{fig:experimental_setup}. It consists of three main parts, the first part being the main OAuth services, which are the authorization server, the resource server, and the client, to make OAuth network traffic in general possible. The second part is the dataset generation part, which is done through fuzzing requests in the OAuth environment, which produces logs in the form of ``.pcap''-files through the logger services. The third and last part is the analysis part, which is initialized through the preprocessing of zeek, which produces several log files from which the ``http.log'' files are getting processed in the analyzer component. The analyzer component executes the implemented algorithms to detect anomalies.

\begin{figure}[ht]
	\sffamily\footnotesize
	\includegraphics[width=0.5\textwidth]{pic/experimental_setup.png}
	\unitlength=0.75mm
	\special{em:linewidth 0.4pt}
	\linethickness{0.4pt}
	\caption{Overview of the environment for the experiments}
	\label{fig:experimental_setup}
\end{figure}

\subsection{OAuth flow execution and Logging}
For this first part, an OAuth environment was implemented, which consists of several subsystems that are needed to execute the OAuth protocol flow. It consists of two independent networks. The first network contains the authorization provider, resource server and a logging service, and the second network contains the OAuth client service and a logging service. The loggers produce .pcap-files of all activity in their network using "tcpdump". The OAuth authorization framework is practice-oriented. Therefore, the network logs are divided between the auth provider and the client, as in practice, mostly two different parties run these services. 

\subsubsection{Authorization Server and Resource Server}
The implementation of the authorization server and resource server is forked from the \emph{authlib} project version 1.2.1 \cite{authlib2023}. More specifically the ``Flask OAuth Providers'' component is utilized for the authorization and resource server. To make the authorization process more vulnerable the mandatory PKCE feature was deactivated. Making adjustments like this, was the reason for forking the project. In addition the authorization server implementation offers four OAuth grants out of the box, which are among the most essential grants, namely "Implicit Grant", "Authorization Code Grant", "Client Credentials Grant", and "Password Grant". It also implements extensions like the "Refresh Token Grant" and the "PKCE"-extension. Besides the authorization capabilities, the authlib implementation also offers a protected resource in the form of an API, which is only accessible by authorized clients. The protected endpoint is '/api/me' and returns the username of the authenticated and authorized user.

\subsubsection{Client}
The client is a simple static webpage that handles the authorization code flow. It can be used to generate traffic manually, but its primary purpose is to handle redirections as part of the different flows. It is written in HTML, CSS, and Javascript to utilize the Fetch API and the Browser Storage API. An implementation of redirect handling is shown in figure \ref{lst:redirect_handler}. The client is checking if the code query parameter is present in the currently active URL (line 6) when the page loads. If it is present it extracts it and retrieves an access token from the authorization server.

\begin{lstlisting}[language={java}, caption={Example implementation of authorization code handling at the client}, label={lst:redirect_handler}]
// fetch access token on page load, if the code query param is present
window.onload = function() {
	const params = new URLSearchParams(window.location.search);
	const client_id = "<pre-configured client ID>"

	if (params.has("code")) {
		const form = new FormData();
		form.append('grant_type', 'authorization_code');
		form.append('scope', '<some scope>');
		form.append('code', params.get("code"));
		form.append('client_id', client_id);
		fetch('<token endpoint of authorization server>', {
			method: 'POST',
			body: form
		})
	}
}
\end{lstlisting}


\subsubsection{Attacker Callback}
Another service that is implemented using the Python ``http.server'' library is the attacker server, which serves the purpose of a callback handler for attacks that redirect the victim's OAuth flows to the attacker. This means if an authorization code or access token ends up being redirected to this callback server it immediately completes OAuth flows with the stolen authorization codes or access tokens and generates traffic at the auth provider like this. An example implementation for such an attacker server is shown in figure \ref{lst:attacker_server}. The ``do\_GET'' method (line 2) is executed, whenever a GET request reaches the attacker server. If this request contains an authorization code parameter (line 7), the server tries to redeem it at the authorization server (line 16). The server then tries to access protected data at the resource server (line 21).

\begin{minipage}\linewidth
\begin{lstlisting}[language={python}, caption={Example implementation of an attacker server, which handles redirections}, label={lst:attacker_server}] 
class OAuthCallback(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_url = urlparse(self.path)
        query_params = parse_qs(parsed_url.query)

		# Abort if there is no 'code' parameter present.
        assert query_params["code"] is not None

		# Fetch access token with code
        auth_code=query_params["code"]
        data = {"grant_type": "authorization_code",
                  "code": auth_code,
                  "redirect_uri": REDIRECT_URI,
                  "client_id": CLIENT_ID,
                  "client_secret": ""}
        res = r.post(f"{AUTHORIZATION_SERVER_URL}/oauth/token", data=data)
        access_token_data = res.json()

        # Utilize stolen access token
        headers = {"Authorization": f"Bearer {access_token_data['access_token']}"}
        res = r.get(f"{RESOURCE_SERVER_URL}/api/me", headers=headers)
        print("whoami:", res.content)
\end{lstlisting}
\end{minipage}

\subsection{Fuzzing}
The above-described services create a complete environment for executing valid OAuth flows and attacks on OAuth. A generator service was implemented in Python to utilize this whole setup to produce network logs. The generator uses fuzzing to generate network traffic, including attacks randomly, which then gets logged by the logger services attached to the networks of the auth provider and client. The generator also logs whenever an attack is executed in its process output.

\subsection{Analysis}
The last piece of the experimental setup is the intrusion detection mechanism. This part is again a multi-step process. In the beginning, the network logs of the logger services are statically analyzed by the "zeek" IDS using the "--readfile" option of zeek. Zeek then produces so-called "zeek-logs". In order to process the zeek-logs, the "zat" library is used to load the data into Python "pandas" data frames. The reason for this is that "pandas" is a popular Python data analysis library, which already implements several valuable functions, like clustering or model-based algorithms.

\section{Evaluation}
\section{Results}



\chapter{Conclusion}


% =============================Literaturverzeichnis=============================
\begin{raggedright}         % Schaltet Blocksatz ab, erzeugt ein stimmigeres
                            %  Schriftbild im Literaturverzeichnis.
  \printbibliography        % Falls Biblatex verwendet wird.
  \label{sec:literaturverzeichnis}
\end{raggedright}


% ===================================Anhang=====================================
\appendix
\setcounter{figure}{0}
\renewcommand\thetable{A.\arabic{figure}}
\setcounter{table}{0}
\renewcommand\thetable{A.\arabic{table}}
\newpage
% ===

\chapter{Non encoded tables}

\begin{sidewaystable}
		\begin{xltabular}{\linewidth}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|X|}
		\hline
			~ & Mandatory PKCE & Random value state & Invalidation of access token & Invalidate state value & Simple String comparision & Avoid usage of grant types & Sender Constraint Access Token & Audience Constrained Access Token & Issuer identification & 303 Redirect & Not choosable client\_id & No redirect before authentication & No access token in uri & No third-party content on pages involved with OAuth & Appropriate Referer Policy & Open redirection countermeasures & Clickjacking countermeasures \\ \hline
			Insufficient Redirect URI Validation & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ \\ \hline
			Credential Leakage via Referer Headers & x & ~ & x & x & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & x & ~ & ~ \\ \hline
			Credential Leakage via Browser History & ~ & ~ & x & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ \\ \hline
			Mix-Up Attacks & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Authorization Code Injection & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Access Token Injection & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Cross-Site Request Forgery & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			PKCE Downgrade Attack & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Access Token Leakage at the Resource Server & ~ & ~ & ~ & ~ & ~ & ~ & x & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			307 Redirect & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Client Impersonating Resource Owner & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ & ~ \\ \hline
			Authorization Server Redirecting to Phishing Site & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ & ~ & ~ & ~ & ~ \\ \hline
			Unvalidated Redirects and Forwards & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x & ~ \\ \hline
			Clickjacking & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & x \\ \hline
		\end{xltabular}
\end{sidewaystable}
		
% ===========================Selbstständigkeitserklärung======================
\chapter*{Eidesstattliche Versicherung} % war: Selbständigkeitserklärung
\vspace{1cm}

\todo[noline]{Bitte verwenden Sie hier in jedem Fall die offizielle von der Prüfungsbehörde vorgegebene Formulierung der Selbständigkeitserklärung.}
%
Hiermit versichere ich an Eides statt, dass ich die vorliegende Arbeit
selbstständig verfasst und keine anderen als die angegebenen Hilfsmittel –
insbesondere keine im Quellenverzeichnis nicht benannten Internet-Quellen –
benutzt habe. Alle Stellen, die wörtlich oder sinngemäß aus Veröffentlichungen
entnommen wurden, sind als solche kenntlich gemacht. Ich versichere weiterhin,
dass ich die Arbeit vorher nicht in einem anderen Prüfungsverfahren eingereicht
habe und die eingereichte schriftliche Fassung der auf dem elektronischen
Speichermedium entspricht.

Ggf. streichen: Ich bin damit einverstanden, dass meine Abschlussarbeit in den
Bestand der Fachbereichsbibliothek eingestellt wird.

\makeatletter
Hamburg, den {\@date}
\makeatother

\vspace{2cm}
\rule{6cm}{0.25pt}\\
\makeatletter
{\@author} \par
\makeatother




% ================================Literaturliste-Muster==============================
\newpage
\thispagestyle{empty}
\label{sec:literaturliste}
\par\textbf{\textsf{Thema:}} Privacy Enhancing Technologies zum Schutz von Kommunikationsbeziehungen
\par\textbf{\textsf{Bearbeiter:}} Eva Musterfrau, Heinz Mustermann
\par\textbf{\textsf{Datum:}} \today
\bigskip
% ====> Delete me
\begin{tikzpicture}[overlay]
    \node[draw, blue, font=\sffamily\Large, xshift=70mm, yshift=0mm, rounded corners=1mm]{Muster der Literaturliste};
\end{tikzpicture}
% <==== /Delete me
\par\textbf{\Large\textsf{Literaturliste}}

% ================================Todo list==============================
\listoftodos
% \todototoc

\end{document}
